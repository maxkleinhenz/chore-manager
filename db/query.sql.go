// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const findDuties = `-- name: FindDuties :many
WITH week AS (
    SELECT date('now', '-' || strftime('%w', 'now') || ' days') AS start_date,
        date(
            'now',
            '-' || strftime('%w', 'now') || ' days',
            '+7 days'
        ) AS end_date
)
SELECT employees.name AS employee_name,
    chores.id AS chore_id,
    chores.name AS chore_name,
    duties.status,
    duties.assigned_date,
    CASE
        WHEN assigned_date < week.start_date
        AND duties.status = 'pending' THEN "overdue"
        WHEN assigned_date >= week.end_date THEN "future"
        ELSE "current"
    END AS week_status
FROM duties,
    week
    INNER JOIN employees ON duties.employee_id = employees.id
    INNER JOIN chores ON duties.chore_id = chores.id
WHERE (
        -- current week
        assigned_date >= week.start_date
        AND assigned_date < week.end_date
    )
    OR (
        -- overdue
        assigned_date < week.start_date
        AND duties.status = 'pending'
    )
    OR (
        -- future
        assigned_date >= week.end_date
    )
ORDER BY duties.assigned_date,
    chores.id
`

type FindDutiesRow struct {
	EmployeeName string
	ChoreID      int64
	ChoreName    string
	Status       string
	AssignedDate time.Time
	WeekStatus   interface{}
}

func (q *Queries) FindDuties(ctx context.Context) ([]FindDutiesRow, error) {
	rows, err := q.db.QueryContext(ctx, findDuties)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDutiesRow
	for rows.Next() {
		var i FindDutiesRow
		if err := rows.Scan(
			&i.EmployeeName,
			&i.ChoreID,
			&i.ChoreName,
			&i.Status,
			&i.AssignedDate,
			&i.WeekStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
